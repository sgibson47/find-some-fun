{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.Eventbrite = {}));\n})(this, function (exports) {\n  'use strict';\n  /*! *****************************************************************************\r\n  Copyright (c) Microsoft Corporation. All rights reserved.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n  this file except in compliance with the License. You may obtain a copy of the\r\n  License at http://www.apache.org/licenses/LICENSE-2.0\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n  MERCHANTABLITY OR NON-INFRINGEMENT.\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n  and limitations under the License.\r\n  ***************************************************************************** */\n\n  /* global Reflect, Promise */\n\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  function __extends(d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  }\n\n  var _assign = function __assign() {\n    _assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n\n        for (var p in s) {\n          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n      }\n\n      return t;\n    };\n\n    return _assign.apply(this, arguments);\n  };\n\n  function __rest(s, e) {\n    var t = {};\n\n    for (var p in s) {\n      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    }\n\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n      if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n    }\n    return t;\n  }\n\n  (function (self) {\n    if (self.fetch) {\n      return;\n    }\n\n    var support = {\n      searchParams: 'URLSearchParams' in self,\n      iterable: 'Symbol' in self && 'iterator' in Symbol,\n      blob: 'FileReader' in self && 'Blob' in self && function () {\n        try {\n          new Blob();\n          return true;\n        } catch (e) {\n          return false;\n        }\n      }(),\n      formData: 'FormData' in self,\n      arrayBuffer: 'ArrayBuffer' in self\n    };\n\n    if (support.arrayBuffer) {\n      var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];\n\n      var isDataView = function isDataView(obj) {\n        return obj && DataView.prototype.isPrototypeOf(obj);\n      };\n\n      var isArrayBufferView = ArrayBuffer.isView || function (obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;\n      };\n    }\n\n    function normalizeName(name) {\n      if (typeof name !== 'string') {\n        name = String(name);\n      }\n\n      if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n        throw new TypeError('Invalid character in header field name');\n      }\n\n      return name.toLowerCase();\n    }\n\n    function normalizeValue(value) {\n      if (typeof value !== 'string') {\n        value = String(value);\n      }\n\n      return value;\n    } // Build a destructive iterator for the value list\n\n\n    function iteratorFor(items) {\n      var iterator = {\n        next: function next() {\n          var value = items.shift();\n          return {\n            done: value === undefined,\n            value: value\n          };\n        }\n      };\n\n      if (support.iterable) {\n        iterator[Symbol.iterator] = function () {\n          return iterator;\n        };\n      }\n\n      return iterator;\n    }\n\n    function Headers(headers) {\n      this.map = {};\n\n      if (headers instanceof Headers) {\n        headers.forEach(function (value, name) {\n          this.append(name, value);\n        }, this);\n      } else if (Array.isArray(headers)) {\n        headers.forEach(function (header) {\n          this.append(header[0], header[1]);\n        }, this);\n      } else if (headers) {\n        Object.getOwnPropertyNames(headers).forEach(function (name) {\n          this.append(name, headers[name]);\n        }, this);\n      }\n    }\n\n    Headers.prototype.append = function (name, value) {\n      name = normalizeName(name);\n      value = normalizeValue(value);\n      var oldValue = this.map[name];\n      this.map[name] = oldValue ? oldValue + ',' + value : value;\n    };\n\n    Headers.prototype['delete'] = function (name) {\n      delete this.map[normalizeName(name)];\n    };\n\n    Headers.prototype.get = function (name) {\n      name = normalizeName(name);\n      return this.has(name) ? this.map[name] : null;\n    };\n\n    Headers.prototype.has = function (name) {\n      return this.map.hasOwnProperty(normalizeName(name));\n    };\n\n    Headers.prototype.set = function (name, value) {\n      this.map[normalizeName(name)] = normalizeValue(value);\n    };\n\n    Headers.prototype.forEach = function (callback, thisArg) {\n      for (var name in this.map) {\n        if (this.map.hasOwnProperty(name)) {\n          callback.call(thisArg, this.map[name], name, this);\n        }\n      }\n    };\n\n    Headers.prototype.keys = function () {\n      var items = [];\n      this.forEach(function (value, name) {\n        items.push(name);\n      });\n      return iteratorFor(items);\n    };\n\n    Headers.prototype.values = function () {\n      var items = [];\n      this.forEach(function (value) {\n        items.push(value);\n      });\n      return iteratorFor(items);\n    };\n\n    Headers.prototype.entries = function () {\n      var items = [];\n      this.forEach(function (value, name) {\n        items.push([name, value]);\n      });\n      return iteratorFor(items);\n    };\n\n    if (support.iterable) {\n      Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n    }\n\n    function consumed(body) {\n      if (body.bodyUsed) {\n        return Promise.reject(new TypeError('Already read'));\n      }\n\n      body.bodyUsed = true;\n    }\n\n    function fileReaderReady(reader) {\n      return new Promise(function (resolve, reject) {\n        reader.onload = function () {\n          resolve(reader.result);\n        };\n\n        reader.onerror = function () {\n          reject(reader.error);\n        };\n      });\n    }\n\n    function readBlobAsArrayBuffer(blob) {\n      var reader = new FileReader();\n      var promise = fileReaderReady(reader);\n      reader.readAsArrayBuffer(blob);\n      return promise;\n    }\n\n    function readBlobAsText(blob) {\n      var reader = new FileReader();\n      var promise = fileReaderReady(reader);\n      reader.readAsText(blob);\n      return promise;\n    }\n\n    function readArrayBufferAsText(buf) {\n      var view = new Uint8Array(buf);\n      var chars = new Array(view.length);\n\n      for (var i = 0; i < view.length; i++) {\n        chars[i] = String.fromCharCode(view[i]);\n      }\n\n      return chars.join('');\n    }\n\n    function bufferClone(buf) {\n      if (buf.slice) {\n        return buf.slice(0);\n      } else {\n        var view = new Uint8Array(buf.byteLength);\n        view.set(new Uint8Array(buf));\n        return view.buffer;\n      }\n    }\n\n    function Body() {\n      this.bodyUsed = false;\n\n      this._initBody = function (body) {\n        this._bodyInit = body;\n\n        if (!body) {\n          this._bodyText = '';\n        } else if (typeof body === 'string') {\n          this._bodyText = body;\n        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n          this._bodyBlob = body;\n        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n          this._bodyFormData = body;\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this._bodyText = body.toString();\n        } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n          this._bodyArrayBuffer = bufferClone(body.buffer); // IE 10-11 can't handle a DataView body.\n\n          this._bodyInit = new Blob([this._bodyArrayBuffer]);\n        } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n          this._bodyArrayBuffer = bufferClone(body);\n        } else {\n          throw new Error('unsupported BodyInit type');\n        }\n\n        if (!this.headers.get('content-type')) {\n          if (typeof body === 'string') {\n            this.headers.set('content-type', 'text/plain;charset=UTF-8');\n          } else if (this._bodyBlob && this._bodyBlob.type) {\n            this.headers.set('content-type', this._bodyBlob.type);\n          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n            this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n          }\n        }\n      };\n\n      if (support.blob) {\n        this.blob = function () {\n          var rejected = consumed(this);\n\n          if (rejected) {\n            return rejected;\n          }\n\n          if (this._bodyBlob) {\n            return Promise.resolve(this._bodyBlob);\n          } else if (this._bodyArrayBuffer) {\n            return Promise.resolve(new Blob([this._bodyArrayBuffer]));\n          } else if (this._bodyFormData) {\n            throw new Error('could not read FormData body as blob');\n          } else {\n            return Promise.resolve(new Blob([this._bodyText]));\n          }\n        };\n\n        this.arrayBuffer = function () {\n          if (this._bodyArrayBuffer) {\n            return consumed(this) || Promise.resolve(this._bodyArrayBuffer);\n          } else {\n            return this.blob().then(readBlobAsArrayBuffer);\n          }\n        };\n      }\n\n      this.text = function () {\n        var rejected = consumed(this);\n\n        if (rejected) {\n          return rejected;\n        }\n\n        if (this._bodyBlob) {\n          return readBlobAsText(this._bodyBlob);\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as text');\n        } else {\n          return Promise.resolve(this._bodyText);\n        }\n      };\n\n      if (support.formData) {\n        this.formData = function () {\n          return this.text().then(decode);\n        };\n      }\n\n      this.json = function () {\n        return this.text().then(JSON.parse);\n      };\n\n      return this;\n    } // HTTP methods whose capitalization should be normalized\n\n\n    var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n    function normalizeMethod(method) {\n      var upcased = method.toUpperCase();\n      return methods.indexOf(upcased) > -1 ? upcased : method;\n    }\n\n    function Request(input, options) {\n      options = options || {};\n      var body = options.body;\n\n      if (input instanceof Request) {\n        if (input.bodyUsed) {\n          throw new TypeError('Already read');\n        }\n\n        this.url = input.url;\n        this.credentials = input.credentials;\n\n        if (!options.headers) {\n          this.headers = new Headers(input.headers);\n        }\n\n        this.method = input.method;\n        this.mode = input.mode;\n\n        if (!body && input._bodyInit != null) {\n          body = input._bodyInit;\n          input.bodyUsed = true;\n        }\n      } else {\n        this.url = String(input);\n      }\n\n      this.credentials = options.credentials || this.credentials || 'omit';\n\n      if (options.headers || !this.headers) {\n        this.headers = new Headers(options.headers);\n      }\n\n      this.method = normalizeMethod(options.method || this.method || 'GET');\n      this.mode = options.mode || this.mode || null;\n      this.referrer = null;\n\n      if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n        throw new TypeError('Body not allowed for GET or HEAD requests');\n      }\n\n      this._initBody(body);\n    }\n\n    Request.prototype.clone = function () {\n      return new Request(this, {\n        body: this._bodyInit\n      });\n    };\n\n    function decode(body) {\n      var form = new FormData();\n      body.trim().split('&').forEach(function (bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n      return form;\n    }\n\n    function parseHeaders(rawHeaders) {\n      var headers = new Headers();\n      rawHeaders.split(/\\r?\\n/).forEach(function (line) {\n        var parts = line.split(':');\n        var key = parts.shift().trim();\n\n        if (key) {\n          var value = parts.join(':').trim();\n          headers.append(key, value);\n        }\n      });\n      return headers;\n    }\n\n    Body.call(Request.prototype);\n\n    function Response(bodyInit, options) {\n      if (!options) {\n        options = {};\n      }\n\n      this.type = 'default';\n      this.status = 'status' in options ? options.status : 200;\n      this.ok = this.status >= 200 && this.status < 300;\n      this.statusText = 'statusText' in options ? options.statusText : 'OK';\n      this.headers = new Headers(options.headers);\n      this.url = options.url || '';\n\n      this._initBody(bodyInit);\n    }\n\n    Body.call(Response.prototype);\n\n    Response.prototype.clone = function () {\n      return new Response(this._bodyInit, {\n        status: this.status,\n        statusText: this.statusText,\n        headers: new Headers(this.headers),\n        url: this.url\n      });\n    };\n\n    Response.error = function () {\n      var response = new Response(null, {\n        status: 0,\n        statusText: ''\n      });\n      response.type = 'error';\n      return response;\n    };\n\n    var redirectStatuses = [301, 302, 303, 307, 308];\n\n    Response.redirect = function (url, status) {\n      if (redirectStatuses.indexOf(status) === -1) {\n        throw new RangeError('Invalid status code');\n      }\n\n      return new Response(null, {\n        status: status,\n        headers: {\n          location: url\n        }\n      });\n    };\n\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n\n    self.fetch = function (input, init) {\n      return new Promise(function (resolve, reject) {\n        var request = new Request(input, init);\n        var xhr = new XMLHttpRequest();\n\n        xhr.onload = function () {\n          var options = {\n            status: xhr.status,\n            statusText: xhr.statusText,\n            headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n          };\n          options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n          var body = 'response' in xhr ? xhr.response : xhr.responseText;\n          resolve(new Response(body, options));\n        };\n\n        xhr.onerror = function () {\n          reject(new TypeError('Network request failed'));\n        };\n\n        xhr.ontimeout = function () {\n          reject(new TypeError('Network request failed'));\n        };\n\n        xhr.open(request.method, request.url, true);\n\n        if (request.credentials === 'include') {\n          xhr.withCredentials = true;\n        }\n\n        if ('responseType' in xhr && support.blob) {\n          xhr.responseType = 'blob';\n        }\n\n        request.headers.forEach(function (value, name) {\n          xhr.setRequestHeader(name, value);\n        });\n        xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n      });\n    };\n\n    self.fetch.polyfill = true;\n  })(typeof self !== 'undefined' ? self : undefined); // the whatwg-fetch polyfill installs the fetch() function\n  // on the global object (window or self)\n  //\n  // Return that as the export for use in Webpack, Browserify etc.\n\n\n  var fetchNpmBrowserify = self.fetch.bind(self);\n  /**\n   * Return a promise that is resolved or rejected depending on the response's\n   * status code.\n   */\n\n  var _checkStatus = function _checkStatus(res) {\n    if (res.status >= 400) {\n      // Need to wrap the response in an object so that it matches the same error object\n      // returned by _catchStatusError\n      return Promise.reject(res);\n    }\n\n    return Promise.resolve(res);\n  };\n\n  var _tryParseJSON = function _tryParseJSON(res) {\n    try {\n      return res.json()[\"catch\"](function () {\n        return Promise.reject(res);\n      });\n    } catch (error) {\n      return Promise.reject(res);\n    }\n  };\n  /**\n   * Calls fetch on provided url with default options necessary for interacting\n   * with our JSON API. Parses the JSON, provides appropriate headers, and asserts\n   * a valid status from the server.\n   */\n\n\n  var _fetchJSON = function _fetchJSON(url, _a) {\n    if (_a === void 0) {\n      _a = {};\n    }\n\n    var _b = _a.headers,\n        headers = _b === void 0 ? {} : _b,\n        _c = _a.method,\n        method = _c === void 0 ? 'GET' : _c,\n        mode = _a.mode,\n        options = __rest(_a, [\"headers\", \"method\", \"mode\"]);\n\n    var fetchHeaders = headers;\n\n    if (method !== 'GET') {\n      fetchHeaders = _assign({\n        'Content-Type': 'application/json'\n      }, headers);\n    }\n\n    var fetchOptions = _assign({\n      method: method,\n      mode: mode,\n      headers: fetchHeaders,\n      credentials: mode === 'cors' ? 'include' : 'same-origin'\n    }, options);\n\n    return fetch(url, fetchOptions).then(_checkStatus).then(_tryParseJSON);\n  };\n\n  var _hasArgumentsError = function _hasArgumentsError(responseData) {\n    return !!(responseData['error_detail'] && responseData['error_detail']['ARGUMENTS_ERROR']);\n  };\n  /**\n   * Parse v3 errors into an array of objects representing the errors returned by\n   * the API. The format of the parsed errors looks like:\n   *\n   *  {\n   *      status_code: 400,\n   *      error: 'ERROR_CODE',\n   *      description: 'Description of the error\n   *  }\n   *\n   * An ARGUMENTS_ERROR looks like:\n   *\n   *  {\n   *      error: 'ARGUMENTS_ERROR',\n   *      description: 'Some of the fields were invalid or something',\n   *      argumentErrors: {\n   *          attr1: ['INVALID'],\n   *          attr2: ['This field is required']\n   *      }\n   *  }\n   *\n   */\n\n\n  var _parseError = function _parseError(responseData) {\n    if (!responseData.error) {\n      // Weird error format, return null\n      return null;\n    }\n\n    var error = {\n      error: responseData.error,\n      description: responseData['error_description']\n    };\n\n    if (_hasArgumentsError(responseData)) {\n      error = _assign({}, error, {\n        argumentErrors: responseData['error_detail']['ARGUMENTS_ERROR']\n      });\n    }\n\n    return error;\n  };\n  /**\n   * Designed to work with `_checkStatus`, or any function that\n   * raises an error on an invalid status. The error raised should have a `response`\n   * property with the original response object.\n   *\n   * Example usage:\n   *\n   * _fetchJSON('/api/v3/test/path', {'body': someData})\n   *     .catch(_catchStatusError)\n   *     .then(doSomethingOnSuccess)\n   *     .catch(({response, parsedError}) => doSomethingOnError());\n   */\n\n\n  var _catchStatusError = function _catchStatusError(res) {\n    return new Promise(function (resolve, reject) {\n      _tryParseJSON(res) // handled error, so reject with parsed error data along with response\n      .then(function (responseData) {\n        return reject({\n          response: res,\n          parsedError: _parseError(responseData)\n        });\n      })[\"catch\"](function () {\n        return reject({\n          response: res\n        });\n      });\n    });\n  };\n  /**\n   * Low-level method that makes fetch requests, returning the response formatted as JSON.\n   * It parses errors from API v3 and throws exceptions with those errors\n   */\n\n\n  var jsonRequest = function jsonRequest(url, options) {\n    return _fetchJSON(url, options)[\"catch\"](_catchStatusError);\n  };\n\n  var SNAKE_CASE_MATCH = /_\\w/g;\n\n  var snakeToCamel = function snakeToCamel(str) {\n    return str.replace(SNAKE_CASE_MATCH, function (chars) {\n      return chars[1].toUpperCase();\n    });\n  };\n\n  var transformKeysSnakeToCamel = function transformKeysSnakeToCamel(obj) {\n    return Object.keys(obj).reduce(function (memo, key) {\n      var _a;\n\n      var newValue = obj[key];\n      var camelKey = snakeToCamel(key);\n\n      if (newValue && typeof newValue === 'object' && !Array.isArray(newValue)) {\n        newValue = transformKeysSnakeToCamel(newValue);\n      }\n\n      return _assign({}, memo, (_a = {}, _a[camelKey] = newValue, _a));\n    }, {});\n  };\n  /**\n   * Returns a function that sends a request, and transforms its results\n   */\n\n\n  var makeJsonRequest = function makeJsonRequest(request, transformers) {\n    return function (url, options) {\n      return request(url, options).then(function (response) {\n        return transformers.reduce(function (acc, transformer) {\n          var memo = acc;\n          memo = transformer(response);\n          return memo;\n        }, response);\n      });\n    };\n  };\n  /**\n   * Base API class for creating new API Classes.\n   * Also encapsulates default transformers such as snake to camel.\n   */\n\n\n  var BaseApi =\n  /** @class */\n  function () {\n    function BaseApi(req) {\n      this.request = makeJsonRequest(req, [transformKeysSnakeToCamel]);\n    }\n\n    return BaseApi;\n  }();\n  /**\n   * API for working with Users\n   */\n\n\n  var UserApi =\n  /** @class */\n  function (_super) {\n    __extends(UserApi, _super);\n\n    function UserApi() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    UserApi.prototype.me = function () {\n      return this.request('/users/me/');\n    };\n\n    UserApi.prototype.get = function (id) {\n      return this.request(\"/users/\" + id + \"/\");\n    };\n\n    return UserApi;\n  }(BaseApi);\n  /**\n   * API for working with Organizations\n   */\n\n\n  var OrganizationsApi =\n  /** @class */\n  function (_super) {\n    __extends(OrganizationsApi, _super);\n\n    function OrganizationsApi() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Get organizations based off a user id.\n     * @param {string} userId\n     */\n\n\n    OrganizationsApi.prototype.getByUser = function (userId) {\n      return this.request(\"/users/\" + userId + \"/organizations/\");\n    };\n\n    return OrganizationsApi;\n  }(BaseApi);\n\n  var PAGE_KEY = 'page';\n  var CONTINUATION_KEY = 'continuation';\n  var DEFAULT_API_URL = 'https://www.eventbriteapi.com/v3';\n\n  var makeRequest = function makeRequest(baseUrl, token) {\n    return function (endpoint, options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      var url = \"\" + baseUrl + endpoint;\n      var requestOptions = options;\n\n      if (token) {\n        requestOptions = _assign({}, requestOptions, {\n          headers: _assign({}, requestOptions.headers || {}, {\n            Authorization: \"Bearer \" + token\n          })\n        });\n      }\n\n      return jsonRequest(url, requestOptions);\n    };\n  };\n\n  var eventbrite = function eventbrite(_a) {\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.baseUrl,\n        baseUrl = _c === void 0 ? DEFAULT_API_URL : _c,\n        token = _b.token;\n\n    var jsonRequest$$1 = makeRequest(baseUrl, token);\n    return {\n      request: jsonRequest$$1,\n      users: new UserApi(jsonRequest$$1),\n      organizations: new OrganizationsApi(jsonRequest$$1)\n    };\n  };\n\n  exports.default = eventbrite;\n  exports.PAGE_KEY = PAGE_KEY;\n  exports.CONTINUATION_KEY = CONTINUATION_KEY;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}