{"version":3,"sources":["request.ts"],"names":["_checkStatus","res","status","Promise","reject","resolve","_tryParseJSON","json","catch","error","_fetchJSON","url","headers","method","mode","options","fetchHeaders","fetchOptions","credentials","fetch","then","_hasArgumentsError","responseData","_parseError","description","argumentErrors","_catchStatusError","response","parsedError","jsonRequest"],"mappings":"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","sourcesContent":["import {JSONResponseData, ParsedResponseError} from './types';\nimport 'isomorphic-fetch';\n\n/**\n * Return a promise that is resolved or rejected depending on the response's\n * status code.\n */\nconst _checkStatus = (res: Response): Promise<Response> => {\n    if (res.status >= 400) {\n        // Need to wrap the response in an object so that it matches the same error object\n        // returned by _catchStatusError\n        return Promise.reject(res);\n    }\n    return Promise.resolve(res);\n};\n\nconst _tryParseJSON = <TResponseType>(\n    res: Response\n): Promise<TResponseType> => {\n    try {\n        return (\n            res\n                .json()\n\n                // if JSON cannot parse, it'll return a rejected promise instead\n                // of throwing an error, so we catch that rejection so that we can rejected\n                // with the response like everything else expects\n                .catch(() => Promise.reject(res))\n        );\n    } catch (error) {\n        return Promise.reject(res);\n    }\n};\n\n/**\n * Calls fetch on provided url with default options necessary for interacting\n * with our JSON API. Parses the JSON, provides appropriate headers, and asserts\n * a valid status from the server.\n */\nconst _fetchJSON = <TResponseType>(\n    url: string,\n    {headers = {}, method = 'GET', mode, ...options}: RequestInit = {}\n): Promise<TResponseType> => {\n    let fetchHeaders = headers as HeadersInit;\n\n    if (method !== 'GET') {\n        fetchHeaders = {\n            'Content-Type': 'application/json',\n            ...headers,\n        };\n    }\n\n    const fetchOptions = {\n        method,\n        mode,\n        headers: fetchHeaders,\n        credentials: mode === 'cors' ? 'include' : 'same-origin',\n        ...options,\n    } as RequestInit;\n\n    return fetch(url, fetchOptions)\n        .then(_checkStatus)\n        .then<TResponseType>(_tryParseJSON);\n};\n\nconst _hasArgumentsError = (responseData: JSONResponseData): boolean =>\n    !!(\n        responseData['error_detail'] &&\n        responseData['error_detail']['ARGUMENTS_ERROR']\n    );\n\n/**\n * Parse v3 errors into an array of objects representing the errors returned by\n * the API. The format of the parsed errors looks like:\n *\n *  {\n *      status_code: 400,\n *      error: 'ERROR_CODE',\n *      description: 'Description of the error\n *  }\n *\n * An ARGUMENTS_ERROR looks like:\n *\n *  {\n *      error: 'ARGUMENTS_ERROR',\n *      description: 'Some of the fields were invalid or something',\n *      argumentErrors: {\n *          attr1: ['INVALID'],\n *          attr2: ['This field is required']\n *      }\n *  }\n *\n */\nconst _parseError = (responseData: JSONResponseData): ParsedResponseError => {\n    if (!responseData.error) {\n        // Weird error format, return null\n        return null;\n    }\n\n    let error = {\n        error: responseData.error,\n        description: responseData['error_description'],\n    } as ParsedResponseError;\n\n    if (_hasArgumentsError(responseData)) {\n        error = {\n            ...error,\n            argumentErrors: responseData['error_detail']['ARGUMENTS_ERROR'],\n        };\n    }\n\n    return error;\n};\n\n/**\n * Designed to work with `_checkStatus`, or any function that\n * raises an error on an invalid status. The error raised should have a `response`\n * property with the original response object.\n *\n * Example usage:\n *\n * _fetchJSON('/api/v3/test/path', {'body': someData})\n *     .catch(_catchStatusError)\n *     .then(doSomethingOnSuccess)\n *     .catch(({response, parsedError}) => doSomethingOnError());\n */\nconst _catchStatusError = (res: Response): Promise<any> =>\n    new Promise((resolve, reject) => {\n        _tryParseJSON(res)\n            // handled error, so reject with parsed error data along with response\n            .then((responseData: JSONResponseData) =>\n                reject({\n                    response: res,\n                    parsedError: _parseError(responseData),\n                })\n            )\n\n            // Unhandled error\n            .catch(() =>\n                reject({\n                    response: res,\n                })\n            );\n    });\n\nexport interface DefaultApiResponse {\n    [key: string]: any;\n}\n\n/**\n * Low-level method that makes fetch requests, returning the response formatted as JSON.\n * It parses errors from API v3 and throws exceptions with those errors\n */\nconst jsonRequest = <TResponseType = DefaultApiResponse>(\n    url: string,\n    options?: RequestInit\n): Promise<TResponseType> =>\n        _fetchJSON<TResponseType>(url, options).catch(_catchStatusError);\n\nexport default jsonRequest;\n"],"file":"request.js"}