{"version":3,"sources":["request.ts"],"names":["_checkStatus","res","status","Promise","reject","resolve","_tryParseJSON","json","catch","error","_catchStatusError","then","responseData","response","parsedError","description","_objectSpread","argumentErrors","_parseError","url","options","_ref","arguments","length","undefined","_ref$headers","headers","_ref$method","method","mode","_objectWithoutProperties","fetchHeaders","Content-Type","fetchOptions","credentials","fetch","_fetchJSON"],"mappings":"umCAOA,IAAMA,EAAe,SAACC,GAClB,OAAkB,KAAdA,EAAIC,OAGGC,QAAQC,OAAOH,GAEnBE,QAAQE,QAAQJ,IAGrBK,EAAiB,SACnBL,GAEA,IACI,OACIA,EACKM,OAKAC,MAAM,WAAA,OAAML,QAAQC,OAAOH,KAEtC,MAAOQ,GACL,OAAON,QAAQC,OAAOH,KAgGxBS,EAAoB,SAACT,GAAD,OACtB,IAAIE,QAAQ,SAACE,EAASD,GAClBE,EAAcL,GAETU,KAAK,SAACC,GAAD,OACFR,EAAO,CACHS,SAAUZ,EACVa,YAxCA,SAACF,GACjB,IAAKA,EAAaH,MAEd,OAAO,KAGX,IAlCwBG,EAkCpBH,EAAQ,CACRA,MAAOG,EAAaH,MACpBM,YAAaH,EAAY,mBAU7B,OA9CwBA,EAuCDA,GArCP,cACZA,EAAY,aAAZ,kBAqCAH,EAAKO,EAAA,GACEP,EADF,CAEDQ,eAAgBL,EAAY,aAAZ,mBAIjBH,EAsBsBS,CAAYN,OAKhCJ,MAAM,WAAA,OACHJ,EAAO,CACHS,SAAUZ,WAaT,SACjBkB,EACAC,GAFiB,OAlHD,SAChBD,GAEyB,IAAAE,EAAA,EAAAC,UAAAC,aAAAC,IAAAF,UAAA,GAAAA,UAAA,GADuC,GACvCG,EAAAJ,EADxBK,QAAAA,OACwB,IAAAD,EADd,GACcA,EAAAE,EAAAN,EADVO,OAAAA,OACU,IAAAD,EADD,MACCA,EADME,EACNR,EADMQ,KAAST,EACfU,EAAAT,EAAA,CAAA,UAAA,SAAA,SACrBU,EAAeL,EAEJ,QAAXE,IACAG,EAAYf,EAAA,CACRgB,eAAgB,oBACbN,IAIX,IAAMO,EAAYjB,EAAA,CACdY,OAAAA,EACAC,KAAAA,EACAH,QAASK,EACTG,YAAsB,SAATL,EAAkB,UAAY,eACxCT,GAGP,OAAOe,MAAMhB,EAAKc,GACbtB,KAAKX,GACLW,KAAoBL,GA+FrB8B,CAA0BjB,EAAKC,GAASZ,MAAME","file":"request.min.js","sourcesContent":["import {JSONResponseData, ParsedResponseError} from './types';\nimport 'isomorphic-fetch';\n\n/**\n * Return a promise that is resolved or rejected depending on the response's\n * status code.\n */\nconst _checkStatus = (res: Response): Promise<Response> => {\n    if (res.status >= 400) {\n        // Need to wrap the response in an object so that it matches the same error object\n        // returned by _catchStatusError\n        return Promise.reject(res);\n    }\n    return Promise.resolve(res);\n};\n\nconst _tryParseJSON = <TResponseType>(\n    res: Response\n): Promise<TResponseType> => {\n    try {\n        return (\n            res\n                .json()\n\n                // if JSON cannot parse, it'll return a rejected promise instead\n                // of throwing an error, so we catch that rejection so that we can rejected\n                // with the response like everything else expects\n                .catch(() => Promise.reject(res))\n        );\n    } catch (error) {\n        return Promise.reject(res);\n    }\n};\n\n/**\n * Calls fetch on provided url with default options necessary for interacting\n * with our JSON API. Parses the JSON, provides appropriate headers, and asserts\n * a valid status from the server.\n */\nconst _fetchJSON = <TResponseType>(\n    url: string,\n    {headers = {}, method = 'GET', mode, ...options}: RequestInit = {}\n): Promise<TResponseType> => {\n    let fetchHeaders = headers as HeadersInit;\n\n    if (method !== 'GET') {\n        fetchHeaders = {\n            'Content-Type': 'application/json',\n            ...headers,\n        };\n    }\n\n    const fetchOptions = {\n        method,\n        mode,\n        headers: fetchHeaders,\n        credentials: mode === 'cors' ? 'include' : 'same-origin',\n        ...options,\n    } as RequestInit;\n\n    return fetch(url, fetchOptions)\n        .then(_checkStatus)\n        .then<TResponseType>(_tryParseJSON);\n};\n\nconst _hasArgumentsError = (responseData: JSONResponseData): boolean =>\n    !!(\n        responseData['error_detail'] &&\n        responseData['error_detail']['ARGUMENTS_ERROR']\n    );\n\n/**\n * Parse v3 errors into an array of objects representing the errors returned by\n * the API. The format of the parsed errors looks like:\n *\n *  {\n *      status_code: 400,\n *      error: 'ERROR_CODE',\n *      description: 'Description of the error\n *  }\n *\n * An ARGUMENTS_ERROR looks like:\n *\n *  {\n *      error: 'ARGUMENTS_ERROR',\n *      description: 'Some of the fields were invalid or something',\n *      argumentErrors: {\n *          attr1: ['INVALID'],\n *          attr2: ['This field is required']\n *      }\n *  }\n *\n */\nconst _parseError = (responseData: JSONResponseData): ParsedResponseError => {\n    if (!responseData.error) {\n        // Weird error format, return null\n        return null;\n    }\n\n    let error = {\n        error: responseData.error,\n        description: responseData['error_description'],\n    } as ParsedResponseError;\n\n    if (_hasArgumentsError(responseData)) {\n        error = {\n            ...error,\n            argumentErrors: responseData['error_detail']['ARGUMENTS_ERROR'],\n        };\n    }\n\n    return error;\n};\n\n/**\n * Designed to work with `_checkStatus`, or any function that\n * raises an error on an invalid status. The error raised should have a `response`\n * property with the original response object.\n *\n * Example usage:\n *\n * _fetchJSON('/api/v3/test/path', {'body': someData})\n *     .catch(_catchStatusError)\n *     .then(doSomethingOnSuccess)\n *     .catch(({response, parsedError}) => doSomethingOnError());\n */\nconst _catchStatusError = (res: Response): Promise<any> =>\n    new Promise((resolve, reject) => {\n        _tryParseJSON(res)\n            // handled error, so reject with parsed error data along with response\n            .then((responseData: JSONResponseData) =>\n                reject({\n                    response: res,\n                    parsedError: _parseError(responseData),\n                })\n            )\n\n            // Unhandled error\n            .catch(() =>\n                reject({\n                    response: res,\n                })\n            );\n    });\n\nexport interface DefaultApiResponse {\n    [key: string]: any;\n}\n\n/**\n * Low-level method that makes fetch requests, returning the response formatted as JSON.\n * It parses errors from API v3 and throws exceptions with those errors\n */\nconst jsonRequest = <TResponseType = DefaultApiResponse>(\n    url: string,\n    options?: RequestInit\n): Promise<TResponseType> =>\n        _fetchJSON<TResponseType>(url, options).catch(_catchStatusError);\n\nexport default jsonRequest;\n"]}