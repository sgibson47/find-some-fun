(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.Eventbrite = {}));
}(this, function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    }

    (function(self) {

      if (self.fetch) {
        return
      }

      var support = {
        searchParams: 'URLSearchParams' in self,
        iterable: 'Symbol' in self && 'iterator' in Symbol,
        blob: 'FileReader' in self && 'Blob' in self && (function() {
          try {
            new Blob();
            return true
          } catch(e) {
            return false
          }
        })(),
        formData: 'FormData' in self,
        arrayBuffer: 'ArrayBuffer' in self
      };

      if (support.arrayBuffer) {
        var viewClasses = [
          '[object Int8Array]',
          '[object Uint8Array]',
          '[object Uint8ClampedArray]',
          '[object Int16Array]',
          '[object Uint16Array]',
          '[object Int32Array]',
          '[object Uint32Array]',
          '[object Float32Array]',
          '[object Float64Array]'
        ];

        var isDataView = function(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj)
        };

        var isArrayBufferView = ArrayBuffer.isView || function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
        };
      }

      function normalizeName(name) {
        if (typeof name !== 'string') {
          name = String(name);
        }
        if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
          throw new TypeError('Invalid character in header field name')
        }
        return name.toLowerCase()
      }

      function normalizeValue(value) {
        if (typeof value !== 'string') {
          value = String(value);
        }
        return value
      }

      // Build a destructive iterator for the value list
      function iteratorFor(items) {
        var iterator = {
          next: function() {
            var value = items.shift();
            return {done: value === undefined, value: value}
          }
        };

        if (support.iterable) {
          iterator[Symbol.iterator] = function() {
            return iterator
          };
        }

        return iterator
      }

      function Headers(headers) {
        this.map = {};

        if (headers instanceof Headers) {
          headers.forEach(function(value, name) {
            this.append(name, value);
          }, this);
        } else if (Array.isArray(headers)) {
          headers.forEach(function(header) {
            this.append(header[0], header[1]);
          }, this);
        } else if (headers) {
          Object.getOwnPropertyNames(headers).forEach(function(name) {
            this.append(name, headers[name]);
          }, this);
        }
      }

      Headers.prototype.append = function(name, value) {
        name = normalizeName(name);
        value = normalizeValue(value);
        var oldValue = this.map[name];
        this.map[name] = oldValue ? oldValue+','+value : value;
      };

      Headers.prototype['delete'] = function(name) {
        delete this.map[normalizeName(name)];
      };

      Headers.prototype.get = function(name) {
        name = normalizeName(name);
        return this.has(name) ? this.map[name] : null
      };

      Headers.prototype.has = function(name) {
        return this.map.hasOwnProperty(normalizeName(name))
      };

      Headers.prototype.set = function(name, value) {
        this.map[normalizeName(name)] = normalizeValue(value);
      };

      Headers.prototype.forEach = function(callback, thisArg) {
        for (var name in this.map) {
          if (this.map.hasOwnProperty(name)) {
            callback.call(thisArg, this.map[name], name, this);
          }
        }
      };

      Headers.prototype.keys = function() {
        var items = [];
        this.forEach(function(value, name) { items.push(name); });
        return iteratorFor(items)
      };

      Headers.prototype.values = function() {
        var items = [];
        this.forEach(function(value) { items.push(value); });
        return iteratorFor(items)
      };

      Headers.prototype.entries = function() {
        var items = [];
        this.forEach(function(value, name) { items.push([name, value]); });
        return iteratorFor(items)
      };

      if (support.iterable) {
        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
      }

      function consumed(body) {
        if (body.bodyUsed) {
          return Promise.reject(new TypeError('Already read'))
        }
        body.bodyUsed = true;
      }

      function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
          reader.onload = function() {
            resolve(reader.result);
          };
          reader.onerror = function() {
            reject(reader.error);
          };
        })
      }

      function readBlobAsArrayBuffer(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob);
        return promise
      }

      function readBlobAsText(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsText(blob);
        return promise
      }

      function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);

        for (var i = 0; i < view.length; i++) {
          chars[i] = String.fromCharCode(view[i]);
        }
        return chars.join('')
      }

      function bufferClone(buf) {
        if (buf.slice) {
          return buf.slice(0)
        } else {
          var view = new Uint8Array(buf.byteLength);
          view.set(new Uint8Array(buf));
          return view.buffer
        }
      }

      function Body() {
        this.bodyUsed = false;

        this._initBody = function(body) {
          this._bodyInit = body;
          if (!body) {
            this._bodyText = '';
          } else if (typeof body === 'string') {
            this._bodyText = body;
          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this._bodyText = body.toString();
          } else if (support.arrayBuffer && support.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            // IE 10-11 can't handle a DataView body.
            this._bodyInit = new Blob([this._bodyArrayBuffer]);
          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
            this._bodyArrayBuffer = bufferClone(body);
          } else {
            throw new Error('unsupported BodyInit type')
          }

          if (!this.headers.get('content-type')) {
            if (typeof body === 'string') {
              this.headers.set('content-type', 'text/plain;charset=UTF-8');
            } else if (this._bodyBlob && this._bodyBlob.type) {
              this.headers.set('content-type', this._bodyBlob.type);
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
            }
          }
        };

        if (support.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected
            }

            if (this._bodyBlob) {
              return Promise.resolve(this._bodyBlob)
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(new Blob([this._bodyArrayBuffer]))
            } else if (this._bodyFormData) {
              throw new Error('could not read FormData body as blob')
            } else {
              return Promise.resolve(new Blob([this._bodyText]))
            }
          };

          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
            } else {
              return this.blob().then(readBlobAsArrayBuffer)
            }
          };
        }

        this.text = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected
          }

          if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob)
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
          } else if (this._bodyFormData) {
            throw new Error('could not read FormData body as text')
          } else {
            return Promise.resolve(this._bodyText)
          }
        };

        if (support.formData) {
          this.formData = function() {
            return this.text().then(decode)
          };
        }

        this.json = function() {
          return this.text().then(JSON.parse)
        };

        return this
      }

      // HTTP methods whose capitalization should be normalized
      var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

      function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return (methods.indexOf(upcased) > -1) ? upcased : method
      }

      function Request(input, options) {
        options = options || {};
        var body = options.body;

        if (input instanceof Request) {
          if (input.bodyUsed) {
            throw new TypeError('Already read')
          }
          this.url = input.url;
          this.credentials = input.credentials;
          if (!options.headers) {
            this.headers = new Headers(input.headers);
          }
          this.method = input.method;
          this.mode = input.mode;
          if (!body && input._bodyInit != null) {
            body = input._bodyInit;
            input.bodyUsed = true;
          }
        } else {
          this.url = String(input);
        }

        this.credentials = options.credentials || this.credentials || 'omit';
        if (options.headers || !this.headers) {
          this.headers = new Headers(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || 'GET');
        this.mode = options.mode || this.mode || null;
        this.referrer = null;

        if ((this.method === 'GET' || this.method === 'HEAD') && body) {
          throw new TypeError('Body not allowed for GET or HEAD requests')
        }
        this._initBody(body);
      }

      Request.prototype.clone = function() {
        return new Request(this, { body: this._bodyInit })
      };

      function decode(body) {
        var form = new FormData();
        body.trim().split('&').forEach(function(bytes) {
          if (bytes) {
            var split = bytes.split('=');
            var name = split.shift().replace(/\+/g, ' ');
            var value = split.join('=').replace(/\+/g, ' ');
            form.append(decodeURIComponent(name), decodeURIComponent(value));
          }
        });
        return form
      }

      function parseHeaders(rawHeaders) {
        var headers = new Headers();
        rawHeaders.split(/\r?\n/).forEach(function(line) {
          var parts = line.split(':');
          var key = parts.shift().trim();
          if (key) {
            var value = parts.join(':').trim();
            headers.append(key, value);
          }
        });
        return headers
      }

      Body.call(Request.prototype);

      function Response(bodyInit, options) {
        if (!options) {
          options = {};
        }

        this.type = 'default';
        this.status = 'status' in options ? options.status : 200;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = 'statusText' in options ? options.statusText : 'OK';
        this.headers = new Headers(options.headers);
        this.url = options.url || '';
        this._initBody(bodyInit);
      }

      Body.call(Response.prototype);

      Response.prototype.clone = function() {
        return new Response(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers(this.headers),
          url: this.url
        })
      };

      Response.error = function() {
        var response = new Response(null, {status: 0, statusText: ''});
        response.type = 'error';
        return response
      };

      var redirectStatuses = [301, 302, 303, 307, 308];

      Response.redirect = function(url, status) {
        if (redirectStatuses.indexOf(status) === -1) {
          throw new RangeError('Invalid status code')
        }

        return new Response(null, {status: status, headers: {location: url}})
      };

      self.Headers = Headers;
      self.Request = Request;
      self.Response = Response;

      self.fetch = function(input, init) {
        return new Promise(function(resolve, reject) {
          var request = new Request(input, init);
          var xhr = new XMLHttpRequest();

          xhr.onload = function() {
            var options = {
              status: xhr.status,
              statusText: xhr.statusText,
              headers: parseHeaders(xhr.getAllResponseHeaders() || '')
            };
            options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
            var body = 'response' in xhr ? xhr.response : xhr.responseText;
            resolve(new Response(body, options));
          };

          xhr.onerror = function() {
            reject(new TypeError('Network request failed'));
          };

          xhr.ontimeout = function() {
            reject(new TypeError('Network request failed'));
          };

          xhr.open(request.method, request.url, true);

          if (request.credentials === 'include') {
            xhr.withCredentials = true;
          }

          if ('responseType' in xhr && support.blob) {
            xhr.responseType = 'blob';
          }

          request.headers.forEach(function(value, name) {
            xhr.setRequestHeader(name, value);
          });

          xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
        })
      };
      self.fetch.polyfill = true;
    })(typeof self !== 'undefined' ? self : undefined);

    // the whatwg-fetch polyfill installs the fetch() function
    // on the global object (window or self)
    //
    // Return that as the export for use in Webpack, Browserify etc.

    var fetchNpmBrowserify = self.fetch.bind(self);

    /**
     * Return a promise that is resolved or rejected depending on the response's
     * status code.
     */
    var _checkStatus = function (res) {
        if (res.status >= 400) {
            // Need to wrap the response in an object so that it matches the same error object
            // returned by _catchStatusError
            return Promise.reject(res);
        }
        return Promise.resolve(res);
    };
    var _tryParseJSON = function (res) {
        try {
            return (res
                .json()["catch"](function () { return Promise.reject(res); }));
        }
        catch (error) {
            return Promise.reject(res);
        }
    };
    /**
     * Calls fetch on provided url with default options necessary for interacting
     * with our JSON API. Parses the JSON, provides appropriate headers, and asserts
     * a valid status from the server.
     */
    var _fetchJSON = function (url, _a) {
        if (_a === void 0) { _a = {}; }
        var _b = _a.headers, headers = _b === void 0 ? {} : _b, _c = _a.method, method = _c === void 0 ? 'GET' : _c, mode = _a.mode, options = __rest(_a, ["headers", "method", "mode"]);
        var fetchHeaders = headers;
        if (method !== 'GET') {
            fetchHeaders = __assign({ 'Content-Type': 'application/json' }, headers);
        }
        var fetchOptions = __assign({ method: method,
            mode: mode, headers: fetchHeaders, credentials: mode === 'cors' ? 'include' : 'same-origin' }, options);
        return fetch(url, fetchOptions)
            .then(_checkStatus)
            .then(_tryParseJSON);
    };
    var _hasArgumentsError = function (responseData) {
        return !!(responseData['error_detail'] &&
            responseData['error_detail']['ARGUMENTS_ERROR']);
    };
    /**
     * Parse v3 errors into an array of objects representing the errors returned by
     * the API. The format of the parsed errors looks like:
     *
     *  {
     *      status_code: 400,
     *      error: 'ERROR_CODE',
     *      description: 'Description of the error
     *  }
     *
     * An ARGUMENTS_ERROR looks like:
     *
     *  {
     *      error: 'ARGUMENTS_ERROR',
     *      description: 'Some of the fields were invalid or something',
     *      argumentErrors: {
     *          attr1: ['INVALID'],
     *          attr2: ['This field is required']
     *      }
     *  }
     *
     */
    var _parseError = function (responseData) {
        if (!responseData.error) {
            // Weird error format, return null
            return null;
        }
        var error = {
            error: responseData.error,
            description: responseData['error_description']
        };
        if (_hasArgumentsError(responseData)) {
            error = __assign({}, error, { argumentErrors: responseData['error_detail']['ARGUMENTS_ERROR'] });
        }
        return error;
    };
    /**
     * Designed to work with `_checkStatus`, or any function that
     * raises an error on an invalid status. The error raised should have a `response`
     * property with the original response object.
     *
     * Example usage:
     *
     * _fetchJSON('/api/v3/test/path', {'body': someData})
     *     .catch(_catchStatusError)
     *     .then(doSomethingOnSuccess)
     *     .catch(({response, parsedError}) => doSomethingOnError());
     */
    var _catchStatusError = function (res) {
        return new Promise(function (resolve, reject) {
            _tryParseJSON(res)
                // handled error, so reject with parsed error data along with response
                .then(function (responseData) {
                return reject({
                    response: res,
                    parsedError: _parseError(responseData)
                });
            })["catch"](function () {
                return reject({
                    response: res
                });
            });
        });
    };
    /**
     * Low-level method that makes fetch requests, returning the response formatted as JSON.
     * It parses errors from API v3 and throws exceptions with those errors
     */
    var jsonRequest = function (url, options) {
        return _fetchJSON(url, options)["catch"](_catchStatusError);
    };

    var SNAKE_CASE_MATCH = /_\w/g;
    var snakeToCamel = function (str) {
        return str.replace(SNAKE_CASE_MATCH, function (chars) { return chars[1].toUpperCase(); });
    };
    var transformKeysSnakeToCamel = function (obj) {
        return Object.keys(obj).reduce(function (memo, key) {
            var _a;
            var newValue = obj[key];
            var camelKey = snakeToCamel(key);
            if (newValue &&
                typeof newValue === 'object' &&
                !Array.isArray(newValue)) {
                newValue = transformKeysSnakeToCamel(newValue);
            }
            return __assign({}, memo, (_a = {}, _a[camelKey] = newValue, _a));
        }, {});
    };
    /**
     * Returns a function that sends a request, and transforms its results
     */
    var makeJsonRequest = function (request, transformers) { return function (url, options) {
        return request(url, options).then(function (response) {
            return transformers.reduce(function (acc, transformer) {
                var memo = acc;
                memo = transformer(response);
                return memo;
            }, response);
        });
    }; };
    /**
     * Base API class for creating new API Classes.
     * Also encapsulates default transformers such as snake to camel.
     */
    var BaseApi = /** @class */ (function () {
        function BaseApi(req) {
            this.request = makeJsonRequest(req, [transformKeysSnakeToCamel]);
        }
        return BaseApi;
    }());

    /**
     * API for working with Users
     */
    var UserApi = /** @class */ (function (_super) {
        __extends(UserApi, _super);
        function UserApi() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        UserApi.prototype.me = function () {
            return this.request('/users/me/');
        };
        UserApi.prototype.get = function (id) {
            return this.request("/users/" + id + "/");
        };
        return UserApi;
    }(BaseApi));

    /**
     * API for working with Organizations
     */
    var OrganizationsApi = /** @class */ (function (_super) {
        __extends(OrganizationsApi, _super);
        function OrganizationsApi() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Get organizations based off a user id.
         * @param {string} userId
         */
        OrganizationsApi.prototype.getByUser = function (userId) {
            return this.request("/users/" + userId + "/organizations/");
        };
        return OrganizationsApi;
    }(BaseApi));

    var PAGE_KEY = 'page';
    var CONTINUATION_KEY = 'continuation';

    var DEFAULT_API_URL = 'https://www.eventbriteapi.com/v3';
    var makeRequest = function (baseUrl, token) { return function (endpoint, options) {
        if (options === void 0) { options = {}; }
        var url = "" + baseUrl + endpoint;
        var requestOptions = options;
        if (token) {
            requestOptions = __assign({}, requestOptions, { headers: __assign({}, (requestOptions.headers || {}), { Authorization: "Bearer " + token }) });
        }
        return jsonRequest(url, requestOptions);
    }; };
    var eventbrite = function (_a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.baseUrl, baseUrl = _c === void 0 ? DEFAULT_API_URL : _c, token = _b.token;
        var jsonRequest$$1 = makeRequest(baseUrl, token);
        return {
            request: jsonRequest$$1,
            users: new UserApi(jsonRequest$$1),
            organizations: new OrganizationsApi(jsonRequest$$1)
        };
    };

    exports.default = eventbrite;
    exports.PAGE_KEY = PAGE_KEY;
    exports.CONTINUATION_KEY = CONTINUATION_KEY;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=eventbrite.js.map
